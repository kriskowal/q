"use strict";
/*global Q: true, describe: false, it: false, expect: false, afterEach: false,
         require: false, jasmine: false, waitsFor: false, runs: false */

if (typeof Q === "undefined" && typeof require !== "undefined") {
    // For Node compatibility.
    global.Q = require("../q");
    require("./lib/jasmine-promise");
}

var REASON = "this is not an error, but it might show up in the console";

afterEach(function () {
    Q.onerror = null;
});

describe("defer and when", function () {

    it("resolve before when", function () {
        var turn = 0;
        var deferred = Q.defer();
        deferred.resolve(10);
        var promise = Q.when(deferred.promise, function (value) {
            expect(turn).toEqual(1);
            expect(value).toEqual(10);
        });
        turn++;
        return promise;
    });

    it("reject before when", function () {
        var turn = 0;
        var deferred = Q.defer();
        deferred.reject(-1);
        var promise = Q.when(deferred.promise, function () {
            expect(true).toBe(false);
        }, function (value) {
            expect(turn).toEqual(1);
            expect(value).toEqual(-1);
        });
        turn++;
        return promise;
    });

    it("when before resolve", function () {
        var turn = 0;
        var deferred = Q.defer();
        var promise = deferred.promise.then(function (value) {
            expect(turn).toEqual(2);
            expect(value).toEqual(10);
            turn++;
        });
        Q.nextTick(function () {
            expect(turn).toEqual(1);
            deferred.resolve(10);
            turn++;
        });
        turn++;
        return promise;
    });

    it("when before reject", function () {
        var turn = 0;
        var deferred = Q.defer();
        var promise = deferred.promise.then(function () {
            expect(true).toBe(false);
        }, function (value) {
            expect(turn).toEqual(2);
            expect(value).toEqual(-1);
            turn++;
        });
        Q.nextTick(function () {
            expect(turn).toEqual(1);
            deferred.reject(-1);
            turn++;
        });
        turn++;
        return promise;
    });

    it("resolves multiple observers", function (done) {
        var nextTurn = false;

        var resolution = 'Taram pam param!';
        var deferred = Q.defer();
        var count = 10;
        var i = 0;

        function resolve(value) {
            i++;
            expect(value).toBe(resolution);
            expect(nextTurn).toBe(true);
            if (i === count) {
                done();
            }
        }

        while (++i <= count) {
            Q.when(deferred.promise, resolve);
        }

        deferred.resolve(resolution);
        i = 0;
        nextTurn = true;
    });

    it("observers called even after throw", function () {
        var threw = false;
        var deferred = Q.defer();
        Q.when(deferred.promise, function () {
            threw = true;
            throw new Error(REASON);
        });
        var promise = Q.when(deferred.promise, function (value) {
            expect(value).toEqual(10);
        }, function () {
            expect("not").toEqual("here");
        });
        deferred.resolve(10);
        return promise;
    });

    it("returns `undefined` from the deferred's methods", function () {
        expect(Q.defer().resolve()).toBe(undefined);
        expect(Q.defer().reject()).toBe(undefined);
    });

});

describe("always next tick", function () {

    it("generated by `resolve`", function () {
        var turn = 0;
        var promise = Q.when(Q.resolve(), function () {
            expect(turn).toEqual(1);
        });
        turn++;
        return promise;
    });

    it("generated by `reject`", function () {
        var turn = 0;
        var promise = Q.when(Q.reject(), function () {
            expect(true).toBe(false);
        }, function () {
            expect(turn).toEqual(1);
        });
        turn++;
        return promise;
    });

});

describe("progress", function () {

    it("calls a single progress listener", function () {
        var progressed = false;
        var deferred = Q.defer();

        var promise = Q.when(
            deferred.promise,
            function () {
                expect(progressed).toBe(true);
            },
            function () {
                expect(true).toBe(false);
            },
            function () {
                progressed = true;
            }
        );

        deferred.notify();
        deferred.resolve();

        return promise;
    });

    it("calls multiple progress listeners", function () {
        var progressed1 = false;
        var progressed2 = false;
        var deferred = Q.defer();
        var promise = Q.when(
            deferred.promise,
            function () {
                expect(progressed1).toBe(true);
                expect(progressed2).toBe(true);
            },
            function () {
                expect(true).toBe(false);
            },
            function () {
                progressed1 = true;
            }
        );
        Q.when(deferred.promise, null, null, function () {
            progressed2 = true;
        });

        deferred.notify();
        deferred.resolve();

        return promise;
    });

    it("calls all progress listeners even if one throws", function () {
        var progressed1 = false;
        var progressed2 = false;
        var progressed3 = false;
        var deferred = Q.defer();
        var promise = Q.when(
            deferred.promise,
            function () {
                expect(progressed1).toBe(true);
                expect(progressed2).toBe(true);
                expect(progressed3).toBe(true);
            },
            function () {
                expect(true).toBe(false);
            },
            function () {
                progressed1 = true;
            }
        );
        Q.when(deferred.promise, null, null, function () {
            progressed2 = true;
            throw new Error("just a test, ok if it shows up in the console");
        });
        Q.when(deferred.promise, null, null, function () {
            progressed3 = true;
        });

        deferred.notify();
        deferred.resolve();

        // In Node, swallow the eventually-thrown error.
        function uncaughtExceptionHandler() { }
        if (typeof process === "object") {
            process.on("uncaughtException", uncaughtExceptionHandler);
            promise.fin(function () {
                process.removeListener("uncaughtException", uncaughtExceptionHandler);
            });
        }

        return promise;
    });

    it("calls the progress listener even if later rejected", function () {
        var progressed = false;
        var deferred = Q.defer();
        var promise = Q.when(
            deferred.promise,
            function () {
                expect(true).toBe(false);
            },
            function () {
                expect(progressed).toEqual(true);
            },
            function () {
                progressed = true;
            }
        );

        deferred.notify();
        deferred.reject();

        return promise;
    });

    it("calls the progress listener with the notify values", function () {
        var progressValues = [];
        var desiredProgressValues = [{}, {}, "foo", 5];
        var deferred = Q.defer();
        var promise = Q.when(
            deferred.promise,
            function () {
                for (var i = 0; i < desiredProgressValues.length; ++i) {
                    var desired = desiredProgressValues[i];
                    var actual = progressValues[i];
                    expect(actual).toBe(desired);
                }
            },
            function () {
                expect(true).toBe(false);
            },
            function (value) {
                progressValues.push(value);
            }
        );

        for (var i = 0; i < desiredProgressValues.length; ++i) {
            deferred.notify(desiredProgressValues[i]);
        }
        deferred.resolve();

        return promise;
    });

    it("does not call the progress listener if notify is called after fulfillment", function () {
        var deferred = Q.defer();
        var called = false;

        Q.when(deferred.promise, null, null, function () {
            called = true;
        });

        deferred.resolve();
        deferred.notify();

        return Q.delay(10).then(function () {
            expect(called).toBe(false);
        });
    });

    it("does not call the progress listener if notify is called after rejection", function () {
        var deferred = Q.defer();
        var called = false;

        Q.when(deferred.promise, null, null, function () {
            called = true;
        });

        deferred.reject();
        deferred.notify();

        return Q.delay(10).then(function () {
            expect(called).toBe(false);
        });
    });

    it("should not save and re-emit progress notifications", function () {
        var deferred = Q.defer();
        var progressValues = [];

        deferred.notify(1);

        var promise = Q.when(
            deferred.promise,
            function () {
                expect(progressValues).toEqual([2]);
            },
            function () {
                expect(true).toBe(false);
            },
            function (progressValue) {
                progressValues.push(progressValue);
            }
        );

        deferred.notify(2);
        deferred.resolve();

        return promise;
    });

    it("should allow attaching progress listeners w/ .progress", function () {
        var progressed = false;
        var deferred = Q.defer();

        deferred.promise.progress(function () {
            progressed = true;
        });

        deferred.notify();
        deferred.resolve();

        return deferred.promise;
    });

    it("should allow attaching progress listeners w/ Q.progress", function () {
        var progressed = false;
        var deferred = Q.defer();

        Q.progress(deferred.promise, function () {
            progressed = true;
        });

        deferred.notify();
        deferred.resolve();

        return deferred.promise;
    });

    it("should call the progress listener with undefined context", function () {
        var progressed = false;
        var progressContext = {};
        var deferred = Q.defer();
        var promise = Q.when(
            deferred.promise,
            function () {
                expect(progressed).toBe(true);
                expect(progressContext).toBe(undefined);
            },
            function () {
                expect(true).toBe(false);
            },
            function () {
                progressed = true;
                progressContext = this;
            }
        );

        deferred.notify();
        deferred.resolve();

        return promise;
    });

    it("should forward only the first notify argument to listeners", function () {
        var progressValueArrays = [];
        var deferred = Q.defer();

        var promise = Q.when(
            deferred.promise,
            function () {
                expect(progressValueArrays).toEqual([[1], [2], [4]]);
            },
            function () {
                expect(true).toBe(false);
            },
            function () {
                var args = Array.prototype.slice.call(arguments);
                progressValueArrays.push(args);
            }
        );

        deferred.notify(1);
        deferred.notify(2, 3);
        deferred.notify(4, 5, 6);
        deferred.resolve();

        return promise;
    });

    it("should work with .then as well", function () {
        var progressed = false;
        var deferred = Q.defer();

        var promise = deferred.promise.then(
            function () {
                expect(progressed).toBe(true);
            },
            function () {
                expect(true).toBe(false);
            },
            function () {
                progressed = true;
            }
        );

        deferred.notify();
        deferred.resolve();

        return promise;
    });

});

describe("promises for objects", function () {

    describe("get", function () {

        it("fulfills a promise", function () {
            var deferred = Q.defer();
            deferred.resolve({a: 1});
            return deferred.promise.get("a")
            .then(function (a) {
                expect(a).toBe(1);
            });
        });

        it("propagates a rejection", function () {
            var exception = new Error("boo!");
            return Q.fcall(function () {
                throw exception;
            })
            .get("a")
            .then(function () {
                expect("be").toBe("not to be");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

    });

    describe("put", function () {

        it("fulfills a promise", function () {
            var object = {};
            return Q.resolve(object)
            .put('a', 1)
            .then(function (result) {
                expect(result).toBe(object);
                expect(object.a).toBe(1);
            });
        });

        it("propagates a rejection", function () {
            var exception = new Error("Gah!");
            return Q.reject(exception)
            .put("a", 1)
            .then(function (result) {
                expect("frozen over").toBe("quite warm");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

    });

    describe("del", function () {

        it("fulfills a promise", function () {
            var object = {a: 10};
            return Q.fcall(function () {
                return object;
            })
            .del('a')
            .then(function (result) {
                expect('a' in object).toBe(false);
                expect(result).toBe(object);
            }, function (exception) {
                expect("up").toBe("down");
            });
        });

        it("propagates a rejection", function () {
            var exception = new Error("hah-hah");
            return Q.fcall(function () {
                throw exception;
            })
            .del('a')
            .then(function () {
                expect(true).toBe(false);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

    });

    describe("post", function () {

        it("fulfills a promise", function () {
            var subject = {
                a: function a(value) {
                    this._a = value;
                    return 1 + value;
                }
            };
            return Q.when(Q.post(subject, 'a', [1]), function (two) {
                expect(subject._a).toBe(1);
                expect(two).toBe(2);
            });
        });

    });

    describe("invoke", function () {

        it("fulfills a promise", function () {
            var foo;
            var subject = {
                foo: function (_bar) {
                    return _bar;
                },
                bar: function (_foo, _bar) {
                    foo = _foo;
                    return this.foo(_bar);
                }
            };
            return Q.invoke(subject, 'bar', 1, 2)
            .then(function (two) {
                expect(foo).toEqual(1);
                expect(two).toEqual(2);
            });
        });

        it("is rejected for undefined method", function () {
            var subject = {};
            return Q.resolve(subject)
            .invoke('foo')
            .then(function () {
                expect("here").toEqual("not here");
            }, function (exception) {
            });
        });

        it("is rejected for undefined object", function () {
            return Q.resolve()
            .invoke('foo')
            .then(function () {
                expect("here").toEqual("not here");
            }, function (exception) {
            });
        });

    });

    describe("keys", function () {

        it("fulfills a promise", function () {
            return Q.keys({a: 10, b: 20})
            .then(function (keys) {
                expect(keys).toEqual(['a', 'b']);
            });
        });

    });

});

describe("promises for functions", function () {

    describe("fapply", function () {
        it("fulfills a promise using arguments", function () {
            return Q.resolve(function (a, b, c) {
                return a + b + c;
            })
            .fapply([1, 2, 3])
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });
    });

    describe("fcall", function () {
        it("fulfills a promise using arguments", function () {
            return Q.resolve(function (a, b, c) {
                return a + b + c;
            })
            .fcall(1, 2, 3)
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });
    });

    describe("fbind", function () {

        it("accepts a promise for a function", function () {
            return Q.fbind(Q.resolve(function (high, low) {
                return high - low;
            }))
            (2, 1)
            .then(function (difference) {
                expect(difference).toEqual(1);
            });
        });

        it("chains partial application on a promise for a function", function () {
            return Q.resolve(function (a, b) {
                return a * b;
            })
            .fbind(2)(3)
            .then(function (product) {
                expect(product).toEqual(6);
            });
        });

        it("returns a fulfilled promise", function () {
            var result = {};
            var bound = Q.fbind(function () {
                return result;
            });
            return bound()
            .then(function (_result) {
                expect(_result).toBe(result);
            });
        });

        it("returns a rejected promise from a thrown error", function () {
            var exception = new Error("Boo!");
            var bound = Q.fbind(function () {
                throw exception;
            });
            return bound()
            .then(function () {
                expect("flying pigs").toBe("swillin' pigs");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

        it("passes arguments through", function () {
            var x = {}, y = {};
            var bound = Q.fbind(function (a, b) {
                expect(a).toBe(x);
                expect(b).toBe(y);
            });
            return bound(x, y);
        });

        it("passes and also partially applies arguments", function () {
            var x = {}, y = {};
            var bound = Q.fbind(function (a, b) {
                expect(a).toBe(x);
                expect(b).toBe(y);
            }, x);
            return bound(y);
        });

    });

});

describe("valueOf", function () {

    it("of fulfillment", function () {
        expect(Q.resolve(10).valueOf()).toEqual(10);
    });

    it("of rejection", function () {
        var error = new Error("In your face.");
        var rejection = Q.reject(error);
        expect(rejection.valueOf()).toBe(rejection);
        expect(rejection.valueOf().exception).toBe(error);
    });

    it("of deferred", function () {
        var deferred = Q.defer();
        expect(deferred.promise.valueOf()).toBe(deferred.promise);
    });

    it("of deferred rejection", function () {
        var deferred = Q.defer();
        var error = new Error("Rejected!");
        var rejection = Q.reject(error);
        deferred.resolve(rejection);
        expect(deferred.promise.valueOf()).toBe(rejection);
        expect(deferred.promise.valueOf().exception).toBe(error);
    });

    it("of deferred fulfillment", function () {
        var deferred = Q.defer();
        deferred.resolve(10);
        expect(deferred.promise.valueOf()).toBe(10);
    });

    it("of deferred deferred", function () {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);
        expect(a.promise.valueOf()).toBe(b.promise);
    });

    it("should not convert `Date` instances to milliseconds", function () {
        var promise = Q.resolve(new Date(2012, 10, 4));
        expect(promise.valueOf()).toEqual(new Date(2012, 10, 4));
    });

});

describe("promise states", function () {

    it("of fulfilled value", function () {
        expect(Q.isFulfilled(void 0)).toBe(true);
        expect(Q.isRejected(false)).toBe(false);
        expect(Q.isResolved(true)).toBe(true);
    });

    it("of fulfillment", function () {
        var promise = Q.resolve(10);
        expect(Q.isFulfilled(promise)).toBe(true);
        expect(promise.isFulfilled()).toBe(true);
        expect(Q.isRejected(promise)).toBe(false);
        expect(promise.isRejected()).toBe(false);
        expect(Q.isResolved(promise)).toBe(true);
        expect(promise.isResolved()).toBe(true);
    });

    it("of rejection", function () {
        var error = new Error("Oh, snap.");
        var promise = Q.reject(error);
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(true);
        expect(promise.isResolved()).toBe(true);
    });

    it("of deferred", function () {
        var deferred = Q.defer();
        var promise = deferred.promise;
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isResolved()).toBe(false);
    });

    it("of deferred rejection", function () {
        var deferred = Q.defer();
        var rejection = Q.reject(new Error("Rejected!"));
        deferred.resolve(rejection);
        var promise = deferred.promise;
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(true);
        expect(promise.isResolved()).toBe(true);
    });

    it("of deferred fulfillment", function () {
        var deferred = Q.defer();
        deferred.resolve(10);
        var promise = deferred.promise;
        expect(promise.isFulfilled()).toBe(true);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isResolved()).toBe(true);
    });

    it("of deferred deferred", function () {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);
        var promise = a.promise;
        expect(promise.isFulfilled()).toBe(false);
        expect(promise.isRejected()).toBe(false);
        expect(promise.isResolved()).toBe(false);
    });
});

describe("propagation", function () {

    it("propagate through then with no callback", function () {
        return Q.resolve(10)
        .then()
        .then(function (ten) {
            expect(ten).toBe(10);
        });
    });

    it("propagate through then with modifying callback", function () {
        return Q.resolve(10)
        .then(function (ten) {
            return ten + 10;
        })
        .then(function (twen) {
            expect(twen).toBe(20);
        });
    });

    it("errback recovers from exception", function () {
        var error = new Error("Bah!");
        return Q.reject(error)
        .then(null, function (_error) {
            expect(_error).toBe(error);
            return 10;
        })
        .then(function (value) {
            expect(value).toBe(10);
        });
    });

    it("rejection propagates through then with no errback", function () {
        var error = new Error("Foolish mortals!");
        return Q.reject(error)
        .then()
        .then(null, function (_error) {
            expect(_error).toBe(error);
        });
    });

    it("rejection intercepted and rethrown", function () {
        var error = new Error("Foolish mortals!");
        var nextError = new Error("Silly humans!");
        return Q.reject(error)
        .fail(function () {
            throw nextError;
        })
        .then(null, function (_error) {
            expect(_error).toBe(nextError);
        });
    });

    it("resolution is forwarded through deferred promise", function () {
        var a = Q.defer();
        var b = Q.defer();
        a.resolve(b.promise);
        b.resolve(10);
        return a.promise.then(function (eh) {
            expect(eh).toEqual(10);
        });
    });

    it("should propagate progress by default", function () {
        var d = Q.defer();

        var progressValues = [];
        var promise = d.promise
        .then()
        .then(
            function () {
                expect(progressValues).toEqual([1]);
            },
            function () {
                expect(true).toBe(false);
            },
            function (progressValue) {
                progressValues.push(progressValue);
            }
        );

        d.notify(1);
        d.resolve();

        return promise;
    });

    it("should allow translation of progress in the progressback", function () {
        var d = Q.defer();

        var progressValues = [];
        var promise = d.promise
        .progress(function (p) {
            return p + 5;
        })
        .then(
            function () {
                expect(progressValues).toEqual([10]);
            },
            function () {
                expect(true).toBe(false);
            },
            function (progressValue) {
                progressValues.push(progressValue);
            }
        );

        d.notify(5);
        d.resolve();

        return promise;
    });
});

describe("all", function () {

    it("resolves when passed an empty array", function () {
        return Q.all([]);
    });

    it("resolves after any constituent promise is rejected", function () {
        var toResolve = Q.defer(); // never resolve
        var toReject = Q.defer();
        var promises = [toResolve.promise, toReject.promise];
        var promise = Q.all(promises);

        toReject.reject(new Error("Rejected"));

        return Q.delay(250)
        .then(function () {
            expect(promise.isRejected()).toBe(true);
        })
        .timeout(1000);
    });

});

describe("allResolved", function () {

    it("normalizes all given values to promises", function () {
        return Q.allResolved([1, Q.resolve(2), Q.reject(3)])
        .then(function (promises) {
            expect(Q.isPromise(promises[0])).toBe(true);
            expect(Q.isPromise(promises[1])).toBe(true);
            expect(Q.isPromise(promises[2])).toBe(true);
        });
    });

    it("fulfillment even when one given promise is rejected", function () {
        return Q.allResolved([1, Q.resolve(2), Q.reject(3)])
        .then(null, function () {
            expect("flying pigs").toBe("flightless pigs");
        });
    });

    it("the state and quantity of promises to be correct", function () {
        return Q.allResolved([1, Q.resolve(2), Q.reject(3)])
        .then(function (promises) {
            expect(promises.length).toEqual(3);

            expect(Q.isPromise(promises[0])).toBe(true);
            expect(Q.isPromise(promises[1])).toBe(true);
            expect(Q.isPromise(promises[2])).toBe(true);

            expect(Q.isResolved(promises[0])).toBe(true);
            expect(Q.isResolved(promises[1])).toBe(true);
            expect(Q.isResolved(promises[2])).toBe(true);

            expect(Q.isFulfilled(promises[0])).toBe(true);
            expect(Q.isFulfilled(promises[1])).toBe(true);
            expect(Q.isRejected(promises[2])).toBe(true);

            expect(promises[0].valueOf()).toEqual(1);
            expect(promises[1].valueOf()).toEqual(2);
        });
    });

    it("is resolved after every constituent promise is resolved", function () {
        var toResolve = Q.defer();
        var toReject = Q.defer();
        var promises = [toResolve.promise, toReject.promise];
        var resolved;
        var rejected;

        Q.fcall(function () {
            toReject.reject();
            rejected = true;
        })
        .then(function () {
            toResolve.resolve();
            resolved = true;
        });

        return Q.allResolved(promises)
        .then(function (promises) {
            expect(resolved).toBe(true);
            expect(rejected).toBe(true);
        });
    });

});

describe("spread", function () {

    it("spreads values across arguments", function () {
        return Q.spread([1, 2, 3], function (a, b, c) {
            expect(b).toBe(2);
        });
    });

    it("spreads promises for arrays across arguments", function () {
        return Q.resolve([Q.resolve(10)])
        .spread(function (value) {
            expect(value).toEqual(10);
        });
    });

    it("spreads arrays of promises across arguments", function () {
        var deferredA = Q.defer();
        var deferredB = Q.defer();

        var promise = Q.spread([deferredA.promise, deferredB.promise],
                               function (a, b) {
            expect(a).toEqual(10);
            expect(b).toEqual(20);
        });

        Q.delay(5).then(function () {
            deferredA.resolve(10);
        });
        Q.delay(10).then(function () {
            deferredB.resolve(20);
        });

        return promise;
    });

    it("calls the errback when given a rejected promise", function () {
        var err = new Error();
        return Q.spread([Q.resolve(10), Q.reject(err)],
            function () {
                expect(true).toBe(false);
            },
            function (actual) {
                expect(actual).toBe(err);
            }
        );
    });

});

describe("fin", function () {

    var exception1 = new Error("boo!");
    var exception2 = new TypeError("evil!");

    describe("when the promise is fulfilled", function () {

        it("should call the callback", function () {
            var called = false;

            return Q.resolve("foo")
            .fin(function () {
                called = true;
            })
            .then(function () {
                expect(called).toBe(true);
            });
        });

        it("should fulfill with the original value", function () {
            return Q.resolve("foo")
            .fin(function () {
                return "bar";
            })
            .then(function (result) {
                expect(result).toBe("foo");
            });
        });

        describe("when the callback returns a promise", function () {

            describe("that is fulfilled", function () {
                it("should fulfill with the original reason after that promise resolves", function () {
                    var promise = Q.delay(250);

                    return Q.resolve("foo")
                    .fin(function () {
                        return promise;
                    })
                    .then(function (result) {
                        expect(Q.isResolved(promise)).toBe(true);
                        expect(result).toBe("foo");
                    });
                });
            });

            describe("that is rejected", function () {
                it("should reject with this new rejection reason", function () {
                    return Q.resolve("foo")
                    .fin(function () {
                        return Q.reject(exception1);
                    })
                    .then(function () {
                        expect(false).toBe(true);
                    },
                    function (exception) {
                        expect(exception).toBe(exception1);
                    });
                });
            });

        });

        describe("when the callback throws an exception", function () {
            it("should reject with this new exception", function () {
                return Q.resolve("foo")
                .fin(function () {
                    throw exception1;
                })
                .then(function () {
                    expect(false).toBe(true);
                },
                function (exception) {
                    expect(exception).toBe(exception1);
                });
            });
        });

    });

    describe("when the promise is rejected", function () {

        it("should call the callback", function () {
            var called = false;

            return Q.reject(exception1)
            .fin(function () {
                called = true;
            })
            .then(function () {
                expect(called).toBe(true);
            }, function () {
                expect(called).toBe(true);
            });
        });

        it("should reject with the original reason", function () {
            return Q.reject(exception1)
            .fin(function () {
                return "bar";
            })
            .then(function (result) {
                expect(false).toBe(true);
            },
            function (exception) {
                expect(exception).toBe(exception1);
            });
        });

        describe("when the callback returns a promise", function () {

            describe("that is fulfilled", function () {
                it("should reject with the original reason after that promise resolves", function () {
                    var promise = Q.delay(250);

                    return Q.reject(exception1)
                    .fin(function () {
                        return promise;
                    })
                    .then(function (result) {
                        expect(false).toBe(true);
                    },
                    function (exception) {
                        expect(exception).toBe(exception1);
                        expect(Q.isResolved(promise)).toBe(true);
                    });
                });
            });

            describe("that is rejected", function () {
                it("should reject with the new reason", function () {
                    var newException = new TypeError("evil!");

                    return Q.reject(exception1)
                    .fin(function () {
                        return Q.reject(exception2);
                    })
                    .then(function (result) {
                        expect(false).toBe(true);
                    },
                    function (exception) {
                        expect(exception).toBe(exception2);
                    });
                });
            });

        });

        describe("when the callback throws an exception", function () {
            it("should reject with this new exception", function () {
                return Q.reject(exception1)
                .fin(function () {
                    throw exception2;
                })
                .then(function () {
                    expect(false).toBe(true);
                },
                function (exception) {
                    expect(exception).toBe(exception2);
                });
            });
        });

    });

});

describe("done", function () {
    describe("when the promise is fulfilled", function () {
        describe("and the callback does not throw", function () {
            it("should call the callback and return nothing", function () {
                var called = false;

                var promise = Q.resolve();

                var returnValue = promise.done(function () {
                    called = true;
                });

                return promise.fail(function () { }).fin(function () {
                    expect(called).toBe(true);
                    expect(returnValue).toBe(undefined);
                });
            });
        });

        describe("and the callback throws", function () {
            it("should rethrow that error in the next turn and return nothing", function () {
                var turn = 0;
                Q.nextTick(function () {
                    ++turn;
                });

                var returnValue = Q.resolve().done(
                    function () {
                        throw "foo";
                    }
                );

                var deferred = Q.defer();
                Q.onerror = function (error) {
                    expect(turn).toBe(1);
                    expect(error).toBe("foo");
                    expect(returnValue).toBe(undefined);
                    deferred.resolve();
                };
                Q.delay(100).then(deferred.reject);

                return deferred.promise;
            });
        });
    });

    describe("when the promise is rejected", function () {
        describe("and the errback handles it", function () {
            it("should call the errback and return nothing", function () {
                var called = false;

                var promise = Q.reject(new Error());

                var returnValue = promise.done(
                    function () { },
                    function () {
                        called = true;
                    }
                );

                return promise.fail(function () { }).fin(function () {
                    expect(called).toBe(true);
                    expect(returnValue).toBe(undefined);
                });
            });
        });

        describe("and the errback throws", function () {
            it("should rethrow that error in the next turn and return nothing", function () {
                var turn = 0;
                Q.nextTick(function () {
                    ++turn;
                });

                var returnValue = Q.reject("bar").done(
                    null,
                    function () {
                        throw "foo";
                    }
                );

                var deferred = Q.defer();
                Q.onerror = function (error) {
                    expect(turn).toBe(1);
                    expect(error).toBe("foo");
                    expect(returnValue).toBe(undefined);
                    deferred.resolve();
                };
                Q.delay(100).then(deferred.reject);

                return deferred.promise;
            });
        });

        describe("and there is no errback", function () {
            it("should throw the original error in the next turn", function () {
                var turn = 0;
                Q.nextTick(function () {
                    ++turn;
                });

                var returnValue = Q.reject("bar").done();

                var deferred = Q.defer();
                Q.onerror = function (error) {
                    expect(turn).toBe(1);
                    expect(error).toBe("bar");
                    expect(returnValue).toBe(undefined);
                    deferred.resolve();
                };
                Q.delay(10).then(deferred.reject);

                return deferred.promise;
            });
        });
    });

    it("should attach a progress listener", function () {
        var deferred = Q.defer();

        var spy = jasmine.createSpy();
        deferred.promise.done(null, null, spy);

        deferred.notify(10);
        deferred.resolve();

        return deferred.promise.then(function () {
            expect(spy).toHaveBeenCalledWith(10);
        });
    });
});

describe("thenResolve", function () {
    describe("Resolving with an object", function () {
        it("returns a promise for that object once the promise is resolved", function () {
            var waited = false;
            Q.delay(20)
                .then(function () {
                    waited = true;
                })
                .thenResolve('foo')
                .then(function (val) {
                    expect(waited).toBe(true);
                    expect(val).toBe('foo');
                });
        });
    });

    describe("Resolving with an promise", function () {
        it("returns a promise for the result of that promise once the promise is resolved", function () {
            var waited = false;
            Q.delay(20)
                .then(function () {
                    waited = true;
                })
                .thenResolve(Q.resolve('foo'))
                .then(function (val) {
                    expect(waited).toBe(true);
                    expect(val).toBe('foo');
                });
        });
    });
});

describe("thenables", function () {

    it("assimilates a thenable with fulfillment with resolve", function () {
        return Q.resolve({
            then: function (resolved) {
                resolved(10);
            }
        })
        .then(function (ten) {
            expect(ten).toEqual(10);
        })
        .then(function (undefined) {
            expect(undefined).toEqual(void 0);
        });
    });

    it("assimilates a thenable with progress and fulfillment (using resolve)", function () {
        var progressValueArrays = [];
        return Q.resolve({
            then: function (fulfilled, rejected, progressed) {
                Q.nextTick(function () {
                    progressed(1, 2);
                    progressed(3, 4, 5);
                    fulfilled();
                });
            }
        })
        .progress(function () {
            progressValueArrays.push(Array.prototype.slice.call(arguments));
        })
        .then(function () {
            expect(progressValueArrays).toEqual([[1], [3]]);
        });
    });

    it("assimilates a thenable with progress and fulfillment (using when)", function () {
        var progressValueArrays = [];
        return Q.when({
            then: function (fulfilled, rejected, progressed) {
                Q.nextTick(function () {
                    progressed(1, 2);
                    progressed(3, 4, 5);
                    fulfilled();
                });
            }
        })
        .progress(function () {
            progressValueArrays.push(Array.prototype.slice.call(arguments));
        })
        .then(function () {
            expect(progressValueArrays).toEqual([[1], [3]]);
        });
    });

    it("flows fulfillment into a promise pipeline", function () {
        return Q.resolve({
            then: function (resolved) {
                resolved([10]);
            }
        })
        .get(0)
        .then(function (ten) {
            expect(ten).toEqual(10);
        });
    });

});

describe("node support", function () {

    var exception = new Error("That is not your favorite color.");

    var obj = {
        method: function (a, b, c, callback) {
            callback(null, a + b + c);
        },
        thispChecker: function (callback) {
            callback(null, this === obj);
        },
        errorCallbacker: function (a, b, c, callback) {
            callback(exception);
        },
        errorThrower: function (a, b, c, callback) {
            throw exception;
        }
    };

    describe("nfapply", function (done) {

        it("fulfills with callback result", function () {
            return Q.nfapply(function (a, b, c, callback) {
                callback(null, a + b + c);
            }, [1, 2, 3])
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });

        it("rejects with callback error", function () {
            var exception = new Error("That is not your favorite color.");
            return Q.nfapply(function (a, b, c, callback) {
                callback(exception);
            }, [1, 2, 3])
            .then(function (sum) {
                expect(true).toBe(false);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

    });

    describe("nfcall", function () {
        it("fulfills with callback result", function () {
            return Q.nfcall(function (a, b, c, callback) {
                callback(null, a + b + c);
            }, 1, 2, 3)
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });

        it("rejects with callback error", function () {
            var exception = new Error("That is not your favorite color.");
            return Q.nfcall(function (a, b, c, callback) {
                callback(exception);
            }, 1, 2, 3)
            .then(function (sum) {
                expect(true).toBe(false);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

    });

    describe("nfbind", function () {

        it("mixes partial application with complete application", function () {
            return Q.nfbind(function (a, b, c, d, callback) {
                callback(null, a + b + c + d);
            }, 1, 2).call({}, 3, 4)
            .then(function (ten) {
                expect(ten).toBe(10);
            });
        });

    });

    describe("npost", function (done) {

        it("fulfills with callback result", function () {
            return Q.npost(obj, "method", [1, 2, 3])
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });

        it("gets the correct thisp", function () {
            return Q.npost(obj, "thispChecker", [])
            .then(function (result) {
                expect(result).toBe(true);
            });
        });

        it("rejects with callback error", function () {
            return Q.npost(obj, "errorCallbacker", [1, 2, 3])
            .then(function (sum) {
                expect("blue").toBe("no, yellow!");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

        it("rejects with thrown error", function () {
            return Q.npost(obj, "errorThrower", [1, 2, 3])
            .then(function (sum) {
                expect(true).toBe(false);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

        it("works on promises for objects with Node methods", function () {
            return Q.resolve(obj)
            .npost("method", [1, 2, 3])
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });

    });

    describe("ninvoke", function (done) {

        it("fulfills with callback result", function () {
            return Q.ninvoke(obj, "method", 1, 2, 3)
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });

        it("gets the correct thisp", function () {
            return Q.ninvoke(obj, "thispChecker")
            .then(function (result) {
                expect(result).toBe(true);
            });
        });

        it("rejects with callback error", function () {
            return Q.ninvoke(obj, "errorCallbacker", 1, 2, 3)
            .then(function (sum) {
                expect("blue").toBe("no, yellow!");
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

        it("rejects with thrown error", function () {
            return Q.ninvoke(obj, "errorThrower", 1, 2, 3)
            .then(function (sum) {
                expect(true).toBe(false);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

        it("works on promises for objects with Node methods", function () {
            return Q.resolve(obj)
            .ninvoke("method", 1, 2, 3)
            .then(function (sum) {
                expect(sum).toEqual(6);
            });
        });

    });

    describe("deferred.makeNodeResolver", function () {

        it("fulfills a promise", function () {
            var deferred = Q.defer();
            var callback = deferred.makeNodeResolver();
            callback(null, 10);
            return deferred.promise.then(function (value) {
                expect(value).toBe(10);
            });
        });

        it("rejects a promise", function () {
            var deferred = Q.defer();
            var callback = deferred.makeNodeResolver();
            var exception = new Error("Holy Exception of Anitoch");
            callback(exception);
            return deferred.promise.then(function (value) {
                expect(5).toBe(3);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });

    });

    describe("nodeify", function () {

        it("calls back with a resolution", function () {
            var spy = jasmine.createSpy();
            Q.resolve(10).nodeify(spy);
            waitsFor(function () {
                return spy.argsForCall.length;
            });
            runs(function () {
                expect(spy.argsForCall).toEqual([[null, 10]]);
            });
        });

        it("calls back with an error", function () {
            var spy = jasmine.createSpy();
            Q.reject(10).nodeify(spy);
            waitsFor(function () {
                return spy.argsForCall.length;
            });
            runs(function () {
                expect(spy.argsForCall).toEqual([[10]]);
            });
        });

        it("forwards a promise", function () {
            return Q.resolve(10).nodeify().then(function (ten) {
                expect(ten).toBe(10);
            });
        });

    });

});

if (typeof require === "function") {
    var domain;
    try {
        domain = require("domain");
    } catch (e) { }

    if (domain) {
        describe("node domain support", function () {
            it("should work for non-promise async inside a promise handler",
               function (done) {
                var error = new Error("should be caught by the domain");
                var d = domain.create();

                d.run(function () {
                    Q.resolve().then(function () {
                        setTimeout(function () {
                            throw error;
                        }, 10);
                    });
                });

                var errorTimeout = setTimeout(function () {
                    done(new Error("Wasn't caught"));
                }, 100);

                d.on("error", function (theError) {
                    expect(theError).toBe(error);
                    clearTimeout(errorTimeout);
                    done();
                });
            });

            it("should transfer errors from `done` into the domain",
               function (done) {
                var error = new Error("should be caught by the domain");
                var d = domain.create();

                d.run(function () {
                    Q.reject(error).done();
                });

                var errorTimeout = setTimeout(function () {
                    done(new Error("Wasn't caught"));
                }, 100);

                d.on("error", function (theError) {
                    expect(theError).toBe(error);
                    clearTimeout(errorTimeout);
                    done();
                });
            });
        });
    }
}

describe("decorator functions", function () {
    describe("promised", function () {
        var exception = new Error("That is not the meaning of life.");
        it("resolves promised arguments", function () {
            var sum = Q.promised(function add(a, b) {
                return a + b;
            });
            return sum(Q.resolve(4), Q.resolve(5)).then(function (sum) {
                expect(sum).toEqual(9);
            });
        });
        it("resolves promised `this`", function () {
            var inc = Q.promised(function inc(a) {
                return this + a;
            });
            return inc.call(Q.resolve(4), Q.resolve(5)).then(function (sum) {
                expect(sum).toEqual(9);
            });
        });
        it("is rejected if an argument is rejected", function () {
            var sum = Q.promised(function add(a, b) {
                return a + b;
            });
            return sum(Q.reject(exception), Q.resolve(4)).then(function () {
                expect(4).toEqual(42);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });
        it("is rejected if `this` is rejected", function () {
            var inc = Q.promised(function inc(a) {
                return this + a;
            });
            return inc.call(Q.reject(exception), Q.resolve(4)).then(function () {
                expect(4).toEqual(42);
            }, function (_exception) {
                expect(_exception).toBe(exception);
            });
        });
    });
});

describe("stack trace formatting", function () {
    it("doesn't mangle a stack trace that gets handled twice", function () {
        var d1 = Q.defer();
        var d2 = Q.defer();
        var captured = [];
        d1.promise.done();
        d2.promise.done();

        Q.onerror = function (err) {
            captured.push(err.stack);
        };

        var error = new Error("boom!");
        d1.reject(error);
        d2.reject(error);

        return Q.all([d1.promise.fail(function () {}), d2.promise.fail(function () { })])
        .then(function () {
            expect(captured[0]).toEqual(captured[1]);
        });
    });
});

describe("possible regressions", function () {

    describe("gh-9", function () {
        it("treats falsy values as resolved values without error", function () {
            expect(Q.isResolved(null)).toEqual(true);
            expect(Q.isResolved(void 0)).toEqual(true);
            expect(Q.isResolved(false)).toEqual(true);
            expect(Q.isResolved()).toEqual(true);
        });
    });

    describe("gh-22", function () {
        it("ensures that the array prototype is intact", function () {
            var keys = [];
            for (var key in []) {
                keys.push(key);
            }
            expect(keys.length).toBe(0);
        });
    });

    describe("gh-73", function () {
        it("does not choke on non-error rejection reasons", function () {
            Q.reject(REASON).done();

            var deferred = Q.defer();

            Q.onerror = function (error) {
                expect(error).toBe(REASON);
                deferred.resolve();
            };
            Q.delay(10).then(deferred.reject);

            return deferred.promise;
        });
    });

    describe("gh-90", function () {
        it("does not choke on rejection reasons with an undefined `stack`", function () {
            var error = new RangeError(REASON);
            error.stack = undefined;
            Q.reject(error).done();

            var deferred = Q.defer();

            Q.onerror = function (theError) {
                expect(theError).toBe(error);
                deferred.resolve();
            };
            Q.delay(10).then(deferred.reject);

            return deferred.promise;
        });
    });

    describe("gh-75", function () {
        it("does not double-resolve misbehaved promises", function () {
            var badPromise = Q.makePromise({
                post: function () { return "hello"; }
            });

            var resolutions = 0;
            function onResolution() {
                ++resolutions;
            }

            return Q.when(badPromise, onResolution, onResolution).then(function () {
                expect(resolutions).toBe(1);
            });
        });
    });

});

